# Part 14: Hashing - The Basics

- Supported Operations
  - puropose
    - maintain a (possibly evolving) set of stuff
  - insert
    - 新しいレコードの追加
  - delete
    - 既存レコードの削除
  - lookup
    - 特定レコードのチェック
  - すべての処理が O(1) でできる
- Application: De-Duplication (重複の削除)
  - given
    - a "stream" of objects
  - goal
    - remove duplicates
    - 例: web site のユニークな visitor を記録する
  - solution
    - when new objects x arrives
      - hash table H から x を探す
      - 見つからなければ x を挿入する
- Application: The 2-SUM Problem
  - input
    - ソートされていない n 個の整数が入っている配列 A
    - ターゲットとなる sum t
  - goal
    - x + y = t となる x と y を A から取得できるかどうか決定する
  - 単純にやると全探索で θ(n^2) 時間かかる
  - Better な方法
    - 1: A をソートする(θ(n log n))
    - 2: A の各要素 x について t - x が A に存在するか二分探索する(θ(n log n))
  - Amazing な方法
    - 1: A の全要素を hash table H に入れる
    - 2: 各 x について t - x を探す (こちらだと θ(n) でできる)
- High-Level Idea
  - setup
    - universe U (all IP addresses など)
  - goal
    - want to maintain evolving set S ⊆ U
  - naive solutions
    - 1: Array-based solution (indexed by u)
      - O(1) で操作できるが、θ(|U|) の空間が必要
    - 2: List-based solution
      - θ(|S|) space だが、探すのに θ(|S|) 時間必要
  - solution
    - 1: pick n = # of "buckets" with n ≒ |S|
      - |S| が極端に大きくないと仮定する
    - 2: hash function を選ぶ。h: U → {0, 1, 2, ..., n - 1}
    - 3: 長さ n の配列 A を使って、x を A[h(x)] に格納する
- Resolving Collisions
  - distinct x, y ∈ U such that h(x) = h(y)
  - solution
    - 1: (separate) chaining
      - 各 bucket に linked list を持たせる
      - key x について、insert / delete / lookup する時、A[h(x)] にあるリストについて処理する
    - 2: open addressing (only one object per bucket)
      - key を格納できるまで、h1(x), h2(x),... と順々に探索していく
- What Makes a Good Hash Function?
  - point
    - パフォーマンスは、どのように hash function を選ぶかに依存する
  - "Good" hash function の特性
    - Should lead to good performance
      - すなわち、データをしっかり分散させること。完全にランダムな hasing は良い hash function
    - Should be easy to store and very fast to evaluate
- Bad Hash Functions
  - 例: key が 10 桁の電話番号
    - h(x) = x の最初の 3 桁
    - h(x) = x の最後の 3 桁
    - これらのような hash function だと、とても攻撃されやすい
  - 例: memory locations (2 の乗数をかけたもの)
    - h(x) = x mod 1000
    - これだと奇数の buckets は空になってしまう

# Part 15: Universal Hashing

## Universal Hashing

- The Load of a Hash Table
  - load factor (負荷率)
    - α = (# of objects in hash table) / (# of buckets of hash table)
  - upshot
    - hash table のパフォーマンスを良くするには、負荷率をコントロールする必要がある
    - hash table のパフォーマンスを良くするには、良い hash function が必要
  - ideal
    - super-clever な hash function が全データを均等に分散させること
  - だがそんな hash function は存在しない。どんな hasu function でもうまく機能させないような data set が存在する
- Solutions
  - 1: Use a cryptographic hash function(SHA-2 など)
  - 2: Use randomization
    - design a family H of hash functions that for all data sets S, "almost all" functions h ∈ H spread S out "pretty evenly"
- Overview of Universal Hashing
  - 1: "good random hash function" の定義
  - 2: 具体例の紹介
  - 3: "good functions" が "good performance" を導くことの証明
- Universal Hash Functions
  - H を U から {0, 1, ..., n - 1} を作成する hash function の集合とする
  - H is universal <=> U に属するすべての x, y (x != y) について、Pr h∈H[x, y collide] <= 1/n
    - h は H の中からランダムに選ばれる。どの h についても衝突確率が 1/n 以下にならないと、universal とは言えない
- 例: Hashing IP Addresses
  - U を IP アドレスの集合とする。(x1, x2, x3, x4)の形式からなり、各 xi ∈ {0, 1, ..., 255}
  - n を素数とし、hash function を 4 つ組(a1, a2, a3, a4)で定義する
    - ai ∈ {0, 1, ..., n - 1} であり、ランダムに選ばれる
  - ha: IP addresses → buckets を以下のように定義する
    - ha(x1, x2, x3, x4) = (a1x1 + a2x2 + a3x3 + a4x4) mod n
  - 証明
    - 2 つの IP アドレス (x1, x2, x3, x4) と (y1, y2, y3, y4) について衝突確率を求める
    - 仮定
      - x4 != y4
    - 衝突する場合は `a1x1 + a2x2 + a3x3 + a4x4 ≡ a1y1 + a2y2 + a3y3 + a4y4 (mod n)`
    - <=> `a4(x4 - y4) ≡ Σ(i=1 to 3) ai(yi - xi) (mod n)`
    - ここで、x4 - y4 は 0 ではないので、左辺は {0, 1, ..., n - 1} に等確率でなる(a4 はランダム、n は素数なので)

## Chaining: Constant-Time Garantee

- Scenario
  - hash table を chaining で実装する。Hash function h は universal family H からランダムに選ばれる
- 定理
  - 全操作 O(1) で実行できる
- 注意と仮定
  - hash function h はランダムに選択されるとする
  - |S| = O(n) と仮定する
  - hash function の評価にかかるのは O(1) と仮定する
- 証明
  - S に存在しない x を探すとする
  - 実行時間は `O(1) + O(list length in A[h(x)])`
  - L を A[h(x)] の list の長さとする
  - y ∈ S (y != x) について、以下のように定める
    - Zy = 1 (if h(y) = h(x))
    - Zy = 0 (otherwise)
  - L = Σ(y∈S) Zy
  - よって E[L] = Σ(y∈S) E[Zy] = Σ(y∈S) Pr[h(y) = h(x)] = |S|/n = load α = O(1)
    - 最後は |S| = O(n) の仮定より

## Open Addressing

- 厳格に証明するのが難しい
- Heuristic Assumption
  - quick & dirty なやり方として、すべての n! の探索の確率が完全に等しいものと仮定する
- Heuristic Analysis
  - Heuristic Assumption のもとだと挿入の期待時間は ≒ 1/1-α (α は load)
  - 証明
    - random probe は空の slot を 1-α の確率で見つけられる
  - 試行回数の期待値 E[N] = 1 + α・E[N] となる。ここで 1 は最初の試行、うまくいかない確率が α でその場合は 2 回目以降の期待値 E[N] をかける
    - よって E[N] = 1/1-α
- Linear Probing(線形探索)
  - ベストな場合の仮定をしていた Heuristic Assumption をやめて、以下の仮定を考える
    - 最初の探索は key の値と独立して、ランダムに行われる
  - この場合の期待時間は 1/(1-α)^2 となる

# Part 16: Bloom Filters

- データ構造の 1 つ
  - [ブルームフィルタ - Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%96%E3%83%AB%E3%83%BC%E3%83%A0%E3%83%95%E3%82%A3%E3%83%AB%E3%82%BF)
- 特徴
  - 基本的には hash table と近く、挿入と探索が速い
  - Hash Table との比較
    - Pros
      - 空間効率がいい
    - Cons
      - can't store an associated object
      - 削除できない
      - small false positive probability
        - 偽陽性(陰性なのに誤って陽性と出てしまうこと)の確率が少しある。偽陰性(陽性なのに誤って陰性と出てしまうこと)はない
- 使用例
  - 基本的には空間効率が求められ、偽陽性が問題にならないもの
  - Original: early spellcheckers
  - Canonical: list of forbidden passwords
  - Modern: network routers
- 中身
  - ingredients
    - 1: n bit の配列
    - k 個の hash functions h1, ..., hk
  - insert(x)
    - for i = 1, 2, ..., k に対して set A[hi(x)] = 1
  - lookup(x)
    - return TRUE <=> A[hi(x)] = 1 for every i = 1, 2, ..., k
  - 偽陰性はない
  - しかし、すべての k について hi(x) = 1 となるような y (y != x) があった場合、誤って陽性と判断してしまう
- Heuristic Analysis
  - intuition
    - 直感的に空間効率とエラーはトレードオフになる
  - 仮定
    - すべての hi(x) はランダムであり、独立
  - setup
    - n bits のデータセット S を bloom filter に入れる
    - この時、ある bit について 1 がセットされている確率は 1 - (1 - 1/n)^(k・|S|)
      - (1 - 1/n)^(k・|S|) が 0 がセットされている確率
    - `1 - (1 - 1/n)^(k・|S|) <= 1 - e^(-k・|S|/n) = 1 - e^-k/b`。ここで b = # of bits per object、n/|S|
  - ここで集合 S に含まれない x が false positive となってしまう確率は `(1 - e^-k/b)^k` 以下。また `(1 - e^-k/b)^k` を error rank ε とする
  - b を固定して ε を最小化するように設定すると `ε ≒ (1/2)^((ln 2)・b), b ≒ 1.44 * log2 1/ε` で、`k ≒ ln2・b ≒ 0.693`
  - 例えば、b が 8 の場合、k を 5 か 6 にすると、エラーの確率は約 2%